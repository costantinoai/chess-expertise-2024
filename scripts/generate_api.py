#!/usr/bin/env python3
"""
Generate API.md by walking analysis folders and extracting public APIs.

Features
- Scans top-level folders starting with 'chess-' (analysis folders).
- For Python files: extracts top-level functions and classes with docstrings via ast.
- For MATLAB files: lists file paths (no parsing) for orientation.
- Writes a consolidated Markdown file (default: API.md).

Usage
  python scripts/generate_api.py --output API.md

Notes
- This script is non-destructive and ignores virtual envs and common build dirs.
- Keep docstrings informative (what and why) so API.md is useful to non-experts.
"""

from __future__ import annotations

import argparse
import logging
import ast
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional, Tuple


TOP_LEVEL_IGNORE = {
    ".git",
    "local",
    "misc",
    "manuscript",
    "tests",
    "scripts",
}

PY_IGNORE_DIRS = {"__pycache__", ".ipynb_checkpoints", ".mypy_cache", ".pytest_cache"}
PY_EXT = ".py"
M_EXT = ".m"


@dataclass
class PySymbol:
    kind: str  # "function" | "class"
    name: str
    signature: Optional[str]
    doc: Optional[str]
    path: Path
    line: int


ANALYSIS_DIR_NAMES = {
    "mvpa",
    "fmri_glm",
    "behavioural",
    "neurosynth",
    "manifold",
    "rois",
}


def iter_analysis_dirs(root: Path) -> Iterable[Path]:
    for p in sorted(root.iterdir()):
        if p.is_dir() and p.name in ANALYSIS_DIR_NAMES and p.name not in TOP_LEVEL_IGNORE:
            yield p


def relpath(p: Path, root: Path) -> str:
    try:
        return str(p.relative_to(root))
    except Exception:
        return str(p)


def parse_python_file(py_path: Path) -> List[PySymbol]:
    text = py_path.read_text(encoding="utf-8", errors="ignore")
    try:
        tree = ast.parse(text)
    except SyntaxError:
        return []

    symbols: List[PySymbol] = []

    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            doc = ast.get_docstring(node)
            sig = f"{node.name}({', '.join(arg.arg for arg in node.args.args)})"
            symbols.append(
                PySymbol("function", node.name, sig, doc, py_path, node.lineno)
            )
        elif isinstance(node, ast.ClassDef):
            doc = ast.get_docstring(node)
            symbols.append(
                PySymbol("class", node.name, node.name, doc, py_path, node.lineno)
            )

    return symbols


def iter_python_files(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.py"):
        parts = set(p.parts)
        if any(part in PY_IGNORE_DIRS for part in parts):
            continue
        if "results" in parts:
            continue
        yield p


def iter_matlab_files(root: Path) -> Iterable[Path]:
    for p in root.rglob("*.m"):
        if "results" in set(p.parts):
            continue
        yield p


def format_doc(doc: Optional[str]) -> str:
    if not doc:
        return ""
    summary = doc.strip().splitlines()[0].strip()
    return summary


def build_markdown(root: Path, analyses: List[Tuple[Path, List[PySymbol], List[Path]]]) -> str:
    lines: List[str] = []
    lines.append("Chess Expertise 2024 — API Reference\n")
    lines.append("This file is generated by `scripts/generate_api.py`. Do not edit manually.\n")
    lines.append("")

    for folder, py_symbols, m_files in analyses:
        lines.append(f"## {folder.name}")
        lines.append("")
        if py_symbols:
            lines.append("- Python Modules:")
            # Group by file
            by_file: dict[str, List[PySymbol]] = {}
            for s in py_symbols:
                by_file.setdefault(relpath(s.path, root), []).append(s)
            for file_rel, symbols in sorted(by_file.items()):
                lines.append(f"  - `{file_rel}`")
                for s in sorted(symbols, key=lambda x: (x.kind, x.name)):
                    doc = format_doc(s.doc)
                    loc = f"{file_rel}:{s.line}"
                    if s.kind == "function":
                        lines.append(f"    - function `{s.signature}` — {doc} ({loc})")
                    else:
                        lines.append(f"    - class `{s.name}` — {doc} ({loc})")
        else:
            lines.append("- Python Modules: none found")

        if m_files:
            lines.append("- MATLAB Files:")
            for m in sorted(m_files):
                lines.append(f"  - `{relpath(m, root)}`")
        else:
            lines.append("- MATLAB Files: none found")

        lines.append("")

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate API.md from source")
    ap.add_argument("--output", "-o", type=Path, default=Path("API.md"), help="Output markdown path")
    args = ap.parse_args()

    root = Path(__file__).resolve().parents[1]

    analyses: List[Tuple[Path, List[PySymbol], List[Path]]] = []
    for folder in iter_analysis_dirs(root):
        py_symbols: List[PySymbol] = []
        for py_file in iter_python_files(folder):
            # Skip package metadata
            if py_file.name == "__init__.py":
                continue
            py_symbols.extend(parse_python_file(py_file))
        m_files = list(iter_matlab_files(folder))
        analyses.append((folder, py_symbols, m_files))

    md = build_markdown(root, analyses)
    args.output.write_text(md, encoding="utf-8")
    logging.basicConfig(level=logging.INFO)
    logging.info("API written to %s", args.output)


if __name__ == "__main__":
    main()
